/******************************************************************************
* Copyright (C) 2023 Advanced Micro Devices, Inc. All Rights Reserved.
* SPDX-License-Identifier: MIT
******************************************************************************/
/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */

#include <stdio.h>
#include "platform.h"
#include "xil_printf.h"
#include "xparameters.h"
#include "xil_io.h"
#include "adc_lite.h"
#include "dac_lite.h"
#include <stdlib.h>
#include <math.h>
void write_data_control_reg(int value) {
	Xil_Out32(XPAR_DAC_LITE_0_S00_AXI_BASEADDR, value);
}

int read_data_in_reg() {
	return Xil_In32 (XPAR_ADC_LITE_0_S00_AXI_BASEADDR);
}
float get_voltage(int data);
void test(float kx,float bx);
float get_offset(int system);
void print_float(float Input);
void calibration(){
	int values[] = {0x01F00000, 0x01B00000};
	float voltage[2];
	float offset[2];
	int data[2];
	for(int i=0;	i<2;	i++){
		write_data_control_reg(values[i]);
		xil_printf("Data went: 0x%08X,", values[i]);
		for (int delay = 0; delay < 10000000; delay++);
		data[i] = read_data_in_reg();
		xil_printf(" Result: 0x%08X\n",data[i]);
		voltage[i] = get_voltage(data[i]);
		offset[i] = get_offset(i);
		if (voltage[i] == -1)
			xil_printf("Huge error,data wrong");
	}
	float kx = (values[1]-values[0])/(data[1]-data[0]);
	print_float("%f",kx);
	float bx = ((offset[1]-offset[0])/(voltage[0]-voltage[1]))*(values[1]-values[0]);
	printf("Your X = %f *x +%f;",kx,bx);
	test(kx,bx);
}
void print_float(float Input)
{
    /*
    * cast input and remove floating part
     */
    long int fix_part = (long int) Input;
    /*
    * remove integer part, multiply by 1000 to adjust to 3 decimal points then cast to integer
    */

    long int frac_part = (long int) (Input*1000.0 - fix_part*1000);
    xil_printf("%d", fix_part);
    xil_printf(".%d\r\n", frac_part);
}
float get_voltage(int data) {
    switch (data) {
        case 0x7F000000: return 0.0;
        case 0x7F001400: return 0.3;
        case 0x7F003000: return 0.88;
        case 0x7F002200: return 0.46;
        case 0x7F003D00: return 0.62;
        default: return -1.0;
    }
}
float get_offset(int system){
	if(system)  //1 for adc
		return 0;
	else return -1.94;	//0 for dac
	return -1;
}
void test(float kx,float bx){
	xil_printf("\n");
	int values[] = {0x01C00000, 0x01D00000};
	int data[2];
	for(int i=0;	i<2;	i++){
		write_data_control_reg(values[i]);
		xil_printf("Data went: 0x%08X,", values[i]);
		for (int delay = 0; delay < 10000000; delay++);
		data[i] = read_data_in_reg();
		xil_printf(" Result: 0x%08X ",data[i]);
		xil_printf(" Expected data: 0x%08X\n",data[i]*kx+bx);
	}
}
int main() {
	init_platform();
	xil_printf("AXI Lite Example Started\n");

	calibration();
    xil_printf("AXI Lite Example Completed\n");
    cleanup_platform();
    return 0;
}
/*
   int values[] = {0x01000000, 0x01B00000, 0x01F00000};
	//int num_values = sizeof(values) / sizeof(values[0]);
	int i=0;
    while(1) {
    	xil_printf("AXI Lite Example transmition started\n");
    	write_data_control_reg(values[i]);
		i = (i + 1) % 3;
        xil_printf("Iteration %d:,", i);

        for (int delay = 0; delay < 10000000; delay++);
        xil_printf("Result: 0x%08X\n", read_data_in_reg());
    }*/
